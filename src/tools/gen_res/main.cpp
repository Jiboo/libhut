#include <cstring>

#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>

#include "hut/utils/chrono.hpp"
#include "hut/utils/glm.hpp"
#include "hut/utils/sstream.hpp"

using namespace std;
using namespace std::filesystem;
using namespace std::chrono;
using namespace hut;

constexpr auto LINE_SIZE = 0x10;

int main(int _argc, char **_argv) {
  try {
    auto start = steady_clock::now();

    if (_argc <= 3)
      throw runtime_error(sstream("usage: ") << _argv[0] << " <namespace> <output> <list of input...>");

    path output_path = _argv[2];
    if (!exists(output_path))
      create_directories(output_path);

    path output_base_path = output_path / _argv[1];
    path output_c_path    = output_base_path;
    output_c_path += ".cpp";
    path output_h_path = output_base_path;
    output_h_path += ".hpp";

    ofstream output_c(output_c_path, ios::out | ios::trunc);
    if (!output_c.is_open())
      throw runtime_error(sstream("can't open ") << output_c_path << ": " << strerror(errno));

    ofstream output_h(output_h_path, ios::out | ios::trunc);
    if (!output_h.is_open())
      throw runtime_error(sstream("can't open ") << output_h_path << ": " << strerror(errno));

    output_h << "// This is an autogenerated file.\n"
                "#pragma once\n"
                "#include <cstdint>\n"
                "#include <array>\n"
                "namespace hut::"
             << _argv[1] << " {\n";

    output_c << "// This is an autogenerated file.\n"
                "#include \""
             << _argv[1]
             << ".hpp\"\n\n"
                "namespace hut::"
             << _argv[1] << " {\n";

    for (auto i = 3; i < _argc; i++) {
      path input_path = _argv[i];

      ifstream input(input_path, ios::ate | ios::binary);
      if (!input.is_open())
        throw runtime_error(sstream("can't open ") << input_path << ": " << strerror(errno));

      string symbol = input_path.filename().string();
      std::replace(symbol.begin(), symbol.end(), '.', '_');
      std::replace(symbol.begin(), symbol.end(), '-', '_');

      auto found_size = input.tellg();
      u64  written    = 0;

      output_h << "extern const std::array<uint8_t, " << dec << found_size << "> " << symbol << ";\n";

      output_c << "const std::array<uint8_t, " << dec << found_size << "> " << symbol << " = {\n";
      input.seekg(0);
      while (!input.eof()) {
        u8 line[LINE_SIZE];
        input.read((char *)line, LINE_SIZE);
        output_c << "\t/*" << hex << setw(6) << setfill('0') << written << "*/ ";
        for (auto c = 0; c < input.gcount(); c++)
          output_c << "0x" << setw(2) << (u32)line[c] << ", ";
        written += input.gcount();
        output_c << "\n";
      }
      output_c << "}; // " << symbol << "\n\n";
    }

    output_c << "}  // namespace hut::" << _argv[1] << '\n';

    output_h << "}  // namespace hut::" << _argv[1] << '\n';

    output_c.flush();
    output_h.flush();

    std::cout << "Generated " << _argv[1] << " at " << output_path << " in "
              << duration<double, std::milli>(steady_clock::now() - start).count() << "ms." << std::endl;

    return EXIT_SUCCESS;
  } catch (const std::exception &e) { std::cerr << "Caught expection: " << e.what() << std::endl; } catch (...) {
    std::cerr << "Caught unknown expection" << std::endl;
  }
  return EXIT_FAILURE;
}
